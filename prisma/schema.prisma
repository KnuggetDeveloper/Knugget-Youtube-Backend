generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum UserPlan {
  FREE
  PREMIUM
}

enum SummaryStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

model User {
  id      String   @id @default(cuid())
  email   String   @unique
  name    String?
  avatar  String?
  plan    UserPlan @default(FREE)
  credits Int      @default(3)

  // Token management for premium users
  inputTokensRemaining  Int       @default(0) // Remaining input tokens for current billing cycle
  outputTokensRemaining Int       @default(0) // Remaining output tokens for current billing cycle
  tokenResetDate        DateTime? // Date when tokens will be reset (billing cycle end)

  // Subscription management
  subscriptionId      String?   @unique // DodoPayments subscription ID
  subscriptionStatus  String?   @default("free") // Current subscription status
  nextBillingDate     DateTime? // Next billing date from DodoPayments
  cancelAtBillingDate Boolean   @default(false) // Will cancel at next billing

  // Firebase integration
  firebaseUid String? @unique

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  lastLoginAt DateTime?

  // Email verification
  emailVerified Boolean @default(false)

  summaries     Summary[]
  refreshTokens RefreshToken[]
  openaiUsage   OpenAIUsage[]

  @@map("users")
}

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
  revoked   Boolean  @default(false)

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("refresh_tokens")
}

model Summary {
  id          String        @id @default(cuid())
  title       String
  keyPoints   String[]      @default([])
  fullSummary String
  tags        String[]      @default([])
  status      SummaryStatus @default(PENDING)

  // Video metadata
  videoId       String
  videoTitle    String
  channelName   String
  videoDuration String?
  videoUrl      String
  thumbnailUrl  String?

  // Transcript data
  transcript     Json? // Store original transcript segments
  transcriptText String? // Flattened transcript for AI processing

  // User relation
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Indexes for performance
  @@index([userId])
  @@index([videoId])
  @@index([createdAt])
  @@map("summaries")
}

model VideoMetadata {
  id           String    @id @default(cuid())
  videoId      String    @unique
  title        String
  channelName  String
  duration     String?
  thumbnailUrl String?
  description  String?
  publishedAt  DateTime?
  viewCount    Int?
  likeCount    Int?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("video_metadata")
}

model ApiUsage {
  id        String  @id @default(cuid())
  userId    String
  endpoint  String
  method    String
  userAgent String?
  ipAddress String?

  // Timestamps
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([createdAt])
  @@map("api_usage")
}

model OpenAIUsage {
  id               String @id @default(cuid())
  userId           String
  operation        String // 'summary_generation', 'completion', etc.
  model            String // 'gpt-4-turbo', 'gpt-3.5-turbo', etc.
  promptTokens     Int
  completionTokens Int
  totalTokens      Int

  // Additional context
  videoId   String? // For summary operations
  summaryId String? // Link to summary if created

  // Timestamps
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
  @@index([operation])
  @@map("openai_usage")
}
